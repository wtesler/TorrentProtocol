#include "TorrentNode.h"
#include "TorrentNodeList.h"
#include "Constants.h"
#include <climits>
#include <iostream>
#include <mpi.h>
#include <string>
#include <sstream>

#define DEBUG false

typedef char BYTE;
typedef int FLAG;

#pragma once
class Manager {

private:

    // Contains the file that you want to share.
    BYTE * data;

    // Prioritized Linked List of segments of data.
    TorrentNodeList * list;

    int networkSize;

    vector<string> messageBuffer;

    MPI_Request * terminationRequests;

public:

    // Constructor
    Manager(int size) : networkSize(size) {

        //a bunch of randomly generated byte data for testing.
        data = new char[DATA_SIZE_IN_BYTES];

        // initialize the data to random values.
        for (unsigned int i = 0; i < DATA_SIZE_IN_BYTES; i++) {
            // rand actually is psuedo-random, but it gets the job done.
            data[i] = rand() % CHAR_MAX;
        }

        // Structure the data into prioritizable chunks
        list = new TorrentNodeList(data, DATA_SIZE_IN_BYTES, CHUNK_SIZE_IN_BYTES);

        terminationRequests = new MPI_Request[networkSize];
    }

    // Destructor
    ~Manager() {
        delete[] data;
        delete list;
        delete[] terminationRequests;
    }

    // Send a chunk of data to each computer inside addresses.
    void sendChunk(BYTE * data, int length, int chunkPosition, int rank) {
        stringstream ss;
        ss << "Manager sending chunk " << chunkPosition << " to Worker " << rank;
        messageBuffer.push_back(ss.str());

        MPI_Send(data, length, MPI_CHAR, rank, TAG_DATA_REQUEST, MPI_COMM_WORLD);
    }

    // This kicks off the Manager and begins the entire uploading/downloading network (swarm)
    void start() {

        // Requests and Statuses used by the Manager.
        MPI_Request dataRequest, terminationRequest;
        MPI_Status dataStatus, terminationStatus;

        // Asynchronously receive data request.
        int chunkPosition;
        FLAG dataFlag = -1;

        int dummy;

        // Keeps track of how many workers have finished
        int numTerminations = 1;

        for (int i = 0; i < networkSize - 1; i++) {
            MPI_Irecv(&dummy, 1, MPI_INT, i+1, TAG_TERMINATION_NOTICE, MPI_COMM_WORLD, &terminationRequests[i]);
        }

        // MAIN LOOP. Will only exit when there are no more workers in the swarm.
        while(numTerminations < networkSize){

            if(dataFlag != 0){
                MPI_Irecv(&chunkPosition, 1, MPI_INT, MPI_ANY_SOURCE, TAG_DATA_REQUEST, MPI_COMM_WORLD, &dataRequest);
                dataFlag = 0;
            }
            // Test to see if a data request has been received.
            MPI_Test(&dataRequest, &dataFlag, &dataStatus);
            // If request has been received.
            if (dataFlag != 0) {
                if (dataStatus.MPI_SOURCE != -1) {
                    //process the new request.
                    processDataRequest(&dataStatus, chunkPosition);
                }
                dataFlag = -1;
            }

            // Test to see if any worker has terminated.
            for (int j = 0; j < networkSize-1; j++) {
                FLAG terminationFlag = -1;
                MPI_Test(&terminationRequests[j], &terminationFlag, &terminationStatus);
                if (terminationFlag != 0) {
                    if (terminationStatus.MPI_SOURCE != -1) {
                        ++numTerminations;
                    }
                } 
            }
        }

        stringstream ss;
        ss << "Manager has terminated";
        messageBuffer.push_back(ss.str());

        if (DEBUG) {
            for (string s : messageBuffer) {
                cout << s << endl;
            }
        }
    }

    // 1. Extracts info from the request.
    // 2. Adjusts list to reflect info.
    // 3. Conditionally sends a work order to the source.
    void processDataRequest(const MPI_Status * status, const int chunkPosition) {

        // The computer that sent us the request.
        int source = status->MPI_SOURCE;

        stringstream ss;
        ss << "Worker " << source << " wants chunk " << chunkPosition;
        messageBuffer.push_back(ss.str());

        // This is the chunk that source wants
        TorrentNode * desiredChunk = static_cast<TorrentNode*>(&list->nodeAt(chunkPosition));

        sendChunk(desiredChunk->getData(), desiredChunk->getDataLength(),
            desiredChunk->getPosition(), source);

    }


};
